SOLID
===

Эти принципы, когда применяются вместе, предназначены для повышения вероятности того, что программист создаст систему, которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID — это руководства, которые могут применяться во время работы над программным обеспечением для удаления «кода с запашком» предписывая программисту выполнять рефакторинг исходного кода, пока тот не станет разборчиво написанным и расширяемым. Это часть общей стратегии гибкой и адаптивной разработки.

## Принцип единственной ответственности (Single responsibility)

> На каждый объект должна быть возложена одна единственная обязанность

Для этого проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный класс.

## Принцип открытости/закрытости (Open-closed)

> Программные сущности должны быть открыты для расширения, но закрыты для модификации

Для этого представляем наш класс как «чёрный ящик» и смотрим, можем ли в таком случае изменить его поведение.

## Принцип подстановки Барбары Лисков (Liskov substitution)

> Объекты в программе могут быть заменены их наследниками без изменения свойств программы

Для этого проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло — то принцип не соблюдается

## Принцип разделения интерфейса (Interface segregation)

> Много специализированных интерфейсов лучше, чем один универсальный

Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если необходимо — разбиваем интерфейсы.

## Принцип инверсии зависимостей (Dependency Invertion)

> Зависимости должны строится относительно абстракций, а не деталей

Проверяем, зависят ли классы от каких-то других классов(непосредственно инстанцируют объекты других классов и т.д) и если эта зависимость имеет место, заменяем на зависимость от абстракции.
